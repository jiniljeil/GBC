HW6 



##    bof2

![2-1](bof2-1.jpg)

위 사진에서 KEY를 0x61616161로 정의되어있는 것을 볼 수 있습니다. 

여기서 0x61이란 아스키코드로 소문자'a'를 나타내므로 a를 여러번 사용하여 KEY를 찾아내는 단서임을 알 수 있습니다.

밑에 사진을 보면 innocent라는 변수가 KEY 값이 같은지 조건을 따지는 것을 볼 수 있습니다. 

조건에 맞는 값이 들어가게되면 system 을 통해 root 권한을 가지게 됩니다.

![2-2](bof2-2.jpg)

일단 a가 몇 번 쓰였을 때 오버플로가 일어나는지 찾는 것이 가장 중요한데 이는 vuln라는 함수가 시작되는 지점에서 buf까지의 바이트 사용량 

크기를 통해 알 수 있습니다.

단, main에서 argv[1] 이라는 인자를 받았으므로 ./bof2 `python -c "print('a'*150)"` 이와 같이 전달합니다.

bof0에서 구한 값(대략 150)을 활용해서 실행시켜보면 밑에 사진과 같이 root 권한을 얻을 수 있습니다.

![2-3](bof2-3.jpg)

##    bof3

![3-1](bof3-1.jpg)

위 사진에서 KEY를 0x61로 정의되어있는 것을 볼 수 있습니다. 이는 a 0 0 0 으로 구성되어있어 이를 x61\x00\x00\x00 으로 나타낼 수 있습니다. 

이를 활용해서 몇 번 쓰였을 때 오버플로가 일어나는지 찾아야하는데 한번에 각 2바이트 씩 총 8바이트를 여러 번 입력하므로 

bof0에서 구했었던 대략 150 정도 되는 값을 4로 나누어 대략 37정도 값을 40이라하고 프린트하게 되면 메모리를 a로 덮으면서 root 권한이 실행되게 됩니다.   
![3-2](bof3-2.jpg)

bof3은 인자가 아닌 표준 함수로 입력 값을 받으므로 파이프를 이용해서 입력해주는데 

밑에 사진에서 볼 수 있듯이 bof2와는 다르게 ;cat 이 들어간 것을 볼 수 있는데 이는 파이프를 사용할 때 

왼쪽 input 파이프가 닫히게 되면 오른쪽 파이프도 닫히게 되는데 오른쪽이 실행되기도 전에 닫히게되면 root 권한을 얻지 못하므로

cat을 이용해서 출력을 가능하게 만들어 주면 밑에 사진과 같이 root 권한을 얻을 수 있습니다.

![3-3](3-3.jpg)

##    bof4

![4-1](4-1.jpg)

위 사진에서 KEY가 0x12345678 임을 알 수 있는데 이를 리틀 엔디안 형식으로 나타내보면 \0x78\0x56\0x34\0x12 로 나타낼 수 있습니다.

이를 활용해서 몇 번 쓰였을 때 오버플로가 일어나는지 찾아야하는데 한번에 각 2바이트 씩 총 8바이트를 여러 번 입력하므로 

bof0에서 구했었던 대략 150 정도 되는 값을 4로 나누어 대략 37정도 값을 프린트하게 되면 입력한 값으로 메모리를 덮어버리면서 

root 권한이 실행되게 됩니다.


![4-2](4-2.jpg)

단, main에서 argv[1] 이라는 인자를 받았으므로 ./bof4 `python -c "print('\78\56\34\12'*36)"` 이와 같이 전달합니다.

밑에 사진을 보면 root 권한을 가진 것을 볼 수 있습니다. 



![4-3](4-3.jpg)

2.처음엔 잘 이해가 안되었지만 모르는 점,궁금한 점 하나하나 잘 알려주셔서 이해하는데 많은 도움이 되었어요 ㅎㅎ 항상 감사합니다~~

   잘가르쳐주셔서 또한 감사드려요 ~~

   