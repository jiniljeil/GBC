리눅스의 부팅 : PC의 전원을 켜는 순간부터 리눅스가 완전히 동작하여 로그인 프롬프트가 출력될 때까지를 의미

리눅스 시스템의 부팅 과정 (사진첨부) 
1. PC 부팅 : 전원 ON -> 바이오스 단계
2. 리눅스 부팅 : 부트 로더 관계 -> 커널 초기화 단계 -> systemd 서비스 단계 -> 로그인 프롬프트 출력

바이오스 단계 (사진첨부)
-->PC의 전원 스위치를 켜서 부팅하면 제일 먼저 바이오스(BIOS, Basic input/output system)가 동작하고
-->보통 ROM에 저장 되어있는 바이오스는 PC에 장착된 기본적인 하드웨어의 상태를 확인한 후 부팅 장치를 선택하여 
부팅 디스크의 첫 섹터에서 512 바이트(마스터 부트 레코드, MBR)를 로딩 
-->메모리에 로딩된 MBR는 부트 로더를 찾아 메모리에 로딩하는 작업까지 수행

부트 로더 단계
부트 로더는 리눅스 커널을 메모리에 로딩하는 역할을 수행 
대표적인 부트 로더 : GRUB 와 LILO

커널 초기화 단계
부트 로더에 의해 메모리에 로딩된 커널은 가장 먼저 시스템에 연결된 메모리, 디스크, 키보드, 마우스 등 장치들을 검사함.
리눅스를 처음 시스템에 설치할 때 사용 가능한 하드웨어 정보를 미리 확인했다가, 부팅할 때 이 장치들이 사용 가능한 상태로 유지되고 있는지 확인
장치 검사 등 초기화 과정이 끝나면 커널은 프로세스와 스레드를 생성, 그렇게 커널 프로세스들이 생성되면 커널이 수행할 작업을 마치게 됨.

systemd 서비스 단계
systemd 서비스는 기존의 init 스크립트를 대체한 것으로 다양한 서비스를 동작시킴.

로그인 프롬프트 출력
systemd 서비스 단계에는 데몬을 모두 실행시킨 뒤 마지막으로 그래픽 로그인 시스템인 GDM을 동작시키고, 로그인 프롬프트를 출력

systemed 서비스
systemd는 리눅스의 시스템과 서비스 관리자로서 기존 유닉스의 init 프로세스가 하던 작업을 대신 수행
즉, systemd는 다양한 서비스 데몬을 시작하고, 프로세스들의 상태를 유지하며, 시스템의 상태를 관리

1.init 프로세스
PID가 1번인 프로세스로 모든 프로세스의 조상 역할
init 프로세스는 부팅 과정에서 각종 서비스를 제공하는 셸 스크립트 파일을 실행

2. init 프로세스와 런레벨
init는 시스템의 단계를 일곱 개로 정의하여 구분하고 각 단계에 따라 셸 스크립트를 실행
런레벨 : 단계들 (사진첨부)

3. systemd의 기본 개념
    systemd 는 전체 시스템을 시작하고 관리하는데 유닛이라 부르는 구성 요소를 사용하고 
    같은 유닛들을 구분하여 관리하며, 관리 대상의 이름을 '서비스 이름.유닛종류'의 형태로 관리함.

    systemd 유닛의 종류 (사진 첨부)

    systemd가 init 방식에 비해 가지는 장점
    - 소켓 기반을 동작하여 inetd와 호환성을 유지
    - 셸과 독립적으로 부팅이 가능
    - 마운트 제어가 가능
    - fsck 제어가 가능
    - 시스템 상태에 대한 스냅숏을 유지 등등
     
4. systemd 관련 명령
  
    systemctl : systemd를 기반으로 서비스를 시작하거나 종료할 때 사용하는 명령
   기능 : systemd 를 제어 
   형식 : systemctl [옵션][명령][유닛 이름]
            옵션 -a : 상태와 관계없이 유닛 전체를 출력
                    -t 유닛 종류 : 지정안 종류의 유닛만 출력
   명령 : start 유닛 시작 
             status 유닛의 상태를 확인
             stop 유닛 서비스 정지하기 등
   
   systemd와 런레벨
   런레벨과 target 유닛의 관계
   런레벨 변경하는 명령어 : systemctl isolate [target 원본파일] 또는 systemctl isolate [target 파일(심벌릭 링크)] , telinit [옵션] [명령]
   
   단일 사용자 모드로 전환하기 : 런레벨 1          
   시스템에 문제가 있을 경우 시스템을 런레벨 1로 변경하여 점검 (안전모드)
   ex ) 명령 : systemctl isolate runlevel1.target
   
   단일 --> 다중 사용자 모드로 전환
   rebott 명령
   systemctl default 명령 사용

   현재 런레벨 확인하기 명령어 : runlevel
   
리눅스 시스템의 종료 방법
- shutdown 명령을 사용
- halt 명령을 사용
- poweroff 명령을 사용
- 런레벨을 0이나 6으로 전환
- reboot 명령을 사용
- 전원을 끔.

1. shutdown 명령을 사용
  * (중요) shutdown 명령은 다양한 종료 방법을 제공 , 또한 런레벨을 바꿀 때도 사용할 수 있음 !!!!
  형식 : shutdown [옵션] [시간] [메세지]
  옵션 : -k : 실제로 시스템을 종료하는 것이 아니라 사용자들에게 메세지만 전달
            -r : 종류 후 재시작
            -h : 종료하며 halt 상태로 이동
            -f  : 빠른 재시작으로 이 과정에서 fsck를 생략할 수도 있음.
            -c : 이전에 내렸던 shutdown 명령을 취소
            시간 : 종료할 시간 (hh:mm, +m , now) 
            메세지 : 모든 사용자에게 보낼 메세지
  ex ) shutdown -h +2 "System is going down in 2 min"
         shutdown -r +3 , shutdown -c 
 
  런레벨 변경을 통한 종료 : telinit 0 또는 telinit 6
  systemed로 종료 : systemctl isolate runlevel0.target

  시스템 종료 및 재시작을 위해 사용할 수 있는 명령 : halt, poweroff, reboot 
  * 중요 ! half, poweroff, reboot 명령들은 모두 systemctl 명령의 심벌릭 링크   

 데몬 프로세스 
 데몬 : 리눅스의 백그라운드에서 동작하면서 특정한 서비스를 제공하는 프로세스를 의미
 
 데몬의 동작 방식
 1. 데몬 혼자서 스스로 동작하는 독자형 방식
  시스템의 백그라운드에 항상 동작하고 있는데 자주 호출되는 데몬이 아니라면 시스템의 자원을 낭비할 우려가 있음.
   
 2. 데몬을 관리하는 슈퍼 데몬에 의해 동작하는 방식
  평소에는 슈퍼 데몬만 동작하다가 서비스 요청이 오면 슈퍼 데몬이 해당 데몬을 동작시키는 것 ==> 약간 시간이 더 걸릴 수 있지만 자원을 효율적으로 사용 (장점)

  슈퍼데몬
 데몬의 종류가 늘어나자 이를 관리하기 위해 슈퍼데몬이 등장하였으며, 네트워크 서비스를 제공하는 데몬만 관리
 요청이 오면 이를 받아 해당하는 서비스 데몬을 동작 시킴. 

  데몬의 조상
  대부분의 데몬을 동작시키는 조상 데몬 / ex ) systemd 와 커널 스레드 데몬
  
  systemd 데몬= init를 대체한 데몬
  1번 프로세스로서 프로세스 대부분의 조상 프로세스로서 , 시스템의 상태를 종합적으로 관리하는 역할을 수행
  (pstree 명령어를 통해 확인 가능)

  커널 스레드 데몬
  커널 데몬 : 커널의 일부분을 프로세스처럼 관리하는 데몬  (ps 명령으로 확인 했을 때 ([])로 둘러싸여 있는 프로세스들)
  역할 : 대부분 입출력이나 메모리 관리, 디스크 동기화 등을 수행하며 대체로 PID 가 낮은 번호로 할당 되어있음.
  *중요! kthreadd (커널 스레드 데몬) : 커널 데몬을 동작시키는 조상 데몬

  부트 로더 ( LILO 와 GRUB )
 역할 : 커널을 메모리에 로딩하는 역할을 수행         
 GRUB가 LILO에 비해 가지는 장점
 - LILO는 리눅스에서만 사용 가능하지만 GRUB는 윈도에서도 사용 가능
 - LILO에 비해 설정과 사용이 편리
 - 부팅 시에 명령을 사용하여 수정이 가능
 - 멀티 부팅 기능을 지원

 GRUB2 관련 디렉터리와 파일
 관련 파일 및 디렉터리
 /etc/grub.d 디렉터리 ,  /boot/grub2/grub.cfg 파일 , /etc/default/grub 파일
  
 단일 사용자 모드로 부팅하기
 * root 계정의 암호를 잊어버렸을 경우 암호를 복구하기 위해 필요
 1. 시스템 재시작하기
     GRUB 메뉴 초기 화면이 출력

 2. GRUB 편집 모드로 전환
     GRUB Boot Menu 가 출력될 때 신속하게 'e' 키를 눌러서 편집 모드로 전환  

 3. 단일 사용자 모드로 수정
     리눅스 커널 정보가 있는 행에서 quiet 다음에 1을 추가하면 런레벨 1로 부팅을 함.
     이때는 단일 사용자 모드로 부팅 후 root 암호를 물어봄.
     따라서 root 암호를 복구하려면 quiet 다음에 init=/bin/bash를 추가 

 4. 재시작하기 
     F10 키를 눌러 재시작 후 부팅된 경우 루트 파일 시스템이 읽기 전용으로 마운트되므로 읽기/쓰기 모드로 다시 마운트해야함.
     이후 passwd root 명령으로 암호를 수정한 후 시스템을 껐다 킨다.
 
     RPM 패키지 설치
     RPM : 대표적인 리눅스 회사인 레드햇에서 만든 패키지 관리 도구
     특징 : 바이너리 파일로 구성되어 있어 컴파일이 필요 없다.
               패키지의 파일들이 관련 디렉터리로 바로 설치
               한 번에 설치된 패키지의 파일을 일괄적으로 삭제할 수 있다.
               패키지에 대한 정보 제공
               패키지의 설치 상태 검증 등
     단점 : 패키지 의존성에 따라 관련 패키지가 먼저 설치되어 있지 않으면 설치 할 수 없다. 이를 해결하기 위해 패키지 관리 도구로서 yum 이 등장
     
  1.  패키지의 이름 구성 
ex) audit-2.3.2-1.fc19.x86_64.rpm
    패키지 이름 , 패키지 버전 , 패키지 릴리즈, 아키텍처 , 확장자
 
    RPM 패키지를 관리하는 명령어 : rpm [옵션]
    옵션 : -vv : 매우 자세하게 디버깅 정보를 출력
              --quiet : 최대한 출력을 자제하고 오류 메세지만 출력
              --help : 도움말을 출력
              --version : 사용 중인 rpm의 버전을 출력
    
 2.  RPM 패키지 설치하는 명령어 : rmp -i [설치 옵션] 패키지명
    옵션 : -h : 해시 기호 출력
              -v : 설치 과정에 대한 메세지를 출력
              --replacefiles : 다른 패키지 파일 덮어쓰고 패키지 강제 설치
              --replacepkgs : 패키지 다시 설치
              --test : 설치하지 않고 충돌 사항이 있는지 점검하고 보고함.

 3. RPM 패키지 업그레이드하여 설치하는 명령어 : rpm [설치 옵션] 패키지명
     옵션 : -h : 해시 기호 출력
               -v : 설치 과정에 대한 메세지를 출력
               -i  : 패키지를 설치     
               -U : 패키지를 업그레이드하여 설치
     ex ) rpm -Uvh lynx-2.8.8-0.1.dev15.fc19.x86_64.rpm
 
4. 패키지 정보 검색하는 명령어 : rpm -q 옵션
     옵션 : -qa : 현재 설치되어 있는 전체 패키지 목록을 출력
               -qa | grep : 특정 패키지가 설치되어 있는지 확인
               -qf : 특정 파일을 포함한 패키지 확인
               -qi , qip , qif: 패키지 상세 정보 확인 
               -ql : 패키지가 설치한 파일 목록 확인
               -qR : 패키지의 의존성 확인
               
5. 패키지 삭제하는 명령 : rpm -e 패키지명 

 yum을 이용한 패키지 설치 
 yum 특징
 -패키지를 분석하여 패키지의 의존성을 해결하고 원격 자동 업데이트와 설치를 할 수 있음.
 -설치 가능한 패키지에 대한 정보가 담긴 저장소를 가지고 있음.
 -저장소의 정보에 의거하여 패키지를 관리

 rpm 기반의 패키지를 자동으로 설치하는 명령어 : yum [옵션] [명령] [패키지명]
  옵션 -h : 도움말을 출력
          -y : 설치 과정의 모든 질문에 yes로 대답
          -v : 자세한 메세지를 출력
  명령 : install , update, check-update (업데이트 가능한 패키지의 목록 출력 ) ,  remove , list , info (패키지 정보 확인)
   ex ) yum install xterm , yum list all

 파일 아카이브와 압축
 아카이브 : 파일을 묶어서 하나로 만든 것이라는 의미
 
 파일 아카이브 
 tar (tape archive) 명령 = 다른 시스템과 파일을 주고받거나, 백업을 하기 위해 여러 파일이나 디렉터리를 하나의 아카이브 파일로 생성하거나,
                                          기존 아카이브에서 파일을 추출하기 위해 사용 
 기능 : 파일과 디렉터리를 묶어 하나의 아카이브 파일을 생성
 형식 : tar 기능 [옵션] [아카이브 파일] 파일 이름
 
 아카이브 생성하기 : cvf 
 c 기능 : 새로운 tar 파일을 생성
 v 기능 : 수정된 파일을 업데이트
 f  기능 : 아카이브 파일이나 데이프 장치를 지정  ex) tar cvf ch2.tar ch2

 아카이브 내용 확인하기 : tvf
 t 기능 : tar 파일의 내용을 출력
 v 기능 : 처리하고 있는 파일의 정보를 출력
 f  기능 : 아카이브 파일이나 데이프 장치를 지정 ex) tar tvf ch2.tar

 아카이브 풀기 : xvf
 x 기능 :  tar 파일에서 원본 파일을 추출
 v 기능 : 처리하고 있는 파일의 정보를 출력
 f 기능 :  아카이브 파일이나 데이프 장치를 지정 ex) tar xvf ch2.tar

 아카이브 업데이트하기 : uvf 
 u 기능 : 수정된 파일을 업데이트한다.
 v 기능 : 처리하고 있는 파일의 정보를 출력
 f 기능 :  아카이브 파일이나 데이프 장치를 지정 ex) tar 

 파일 압축과 아카이브 
 아카이브를 생성하면서 동시에 압축 할 수 있는데, 압출할 경우 생성된 아카이브 파일의 크기가 작아지므로 디스크 공간이 부족할 때 사용하면 좋음.

 파일 압축하기 
 gzip/gunzip : .gz 파일 
 
 gzip 명령은 지정한 파일을 압축하여 '파일 이름.gz'파일을 생성
 형식 : gzip [옵션] 파일 이름
 옵션 : -d : 파일 압축을 해제 
           -l : 압축된 파일의 정보를 출력
           -r : 하위 디렉터리를 이동하여 파일을 압축
           -t : 압축 파일을 검사
           -v : 압축 정보를 화면에 출력
           -g : 최대한 압축         ex ) gzip a.txt    gzip -v b.txt c.txt

 압축 파일의 내용 보는 명령어 : zcat [파일 이름]
 기능 : gz로 압축된 파일의 내용을 출력
 
 압축 푸는 명령어 : gunzip [파일 이름]
 기능 : gz로 압축된 파일의 압축을 품. 
 
 파일 압축 명령어 : bzip2 [옵션] 파일 이름
 gzip에 비해 대체로 압축률은 좋지만 속도가 약간 느림.
 옵션 : -d : 파일 압축을 해제 
           -l  : 압축도니 파일의 내용을 보여줌
           -t  : 압축 파일을 검사
           -v : 압축 정보를 화면에 출력
           --best : 최대한 압축
 
 압축 파일의 내용 보는 명령어 : bzcat [파일 이름]
 기능 : 압축된 파일의 내용을 출력

 압축 푸는 명령어 : bunzip2 [파일 이름]
 기능 : bzip2로 압축된 파일의 압축을 푼다.

 소프트웨어 컴파일 
 컴파일 : 사용자가 사용하는 고급 언어를 기계어로 변환하는 과정 
 C 프로그램 컴파일 : 'gcc 소스파일명'
 
 컴파일 명령 : gcc -o 실행 파일명 소스 파일명
 
 make 명령 : 여러 파일을 연결하여 컴파일하는 명령
 makefile에 설정된 정보를 읽어서 여러 소스 파일을 컴파일하고 링크하여 최종 실행 파일을 만들어줌.
 실제로도 많은 오픈 소스 소프트웨어는 소스 코드와 함께 makefile을 배포함.
  
 makefile 생성 방법
 1. 소스 파일 준비하기 
 2. makefile 작성하기
     makefile : 어떤 소스를 읽고 어떻게 컴파일하여 최종적으로 어떤 실행 파일을 만들면 되는지 make 명령에 알려주는 설정 파일
     
     TARGET = 실행 파일 이름
     OBJACTS = 소스파일 이름들 
     (사진 첨부)

 사용자 관리
-사용자 계정 관련 파일
  1. /etc/passwd
     로그인 ID : x : UID : GID : 설명 : 홈 디렉터리 : 로그인 셸
     
     로그인 ID : 사용자 계정의 이름을 뜻함. x : 사용자 암호 (/etc/shadow 파일에 별도 보관) 
     , UID : 사용자 ID 번호로 시스템이 사용자를 구별하기 위해 사용하는 번호
       0(root) : root 사용자 계정
       1(bin) : 명령어 관리를 위한 계정
       2(daemon) : 시스템 데몬 계정
       3(adm) : 시스템 로그와 관련된 계정
       4(lp) : 프린트 서비스와 관련된 계정
       65534(nfsnobody) : 사용자의 UID로 NFS와 관련된 계정
    
       GID : 그룹 ID
       설명 : 사용자의 실명이나 부서명, 연락처 등 사용자에 대한 일반적인 정보가 기록되는 부분
       홈 디렉터리 : 사용자 계정에 할당된 홈 디렉터리의 절대 경로를 기록
       로그인 셸 : 사용자의 로그인 셸을 지정 , 로그인 셸 ( 사용자가 로그인할 때 기본적으로 동작하는 셸)
     
  2. /etc/shadow
      로그인 ID : 암호 : 최종 변경일 : MIN : MAX : WARNING : INACTIVE : EXPIRE : Flag
      
      최종 변경일 : 암호가 마지막으로 변경된 날짜
      MIN : 암호를 변경한 후 사용해야하는 최소 기간 
      MAX : 암호를 사용할 수 있는 최대 기간
      WARNING : 암호가 만료되기 전에 경고를 시작하는 날수
      INCATIVE : 암호가 만료된 후에도 이 항목에 지정한 날수 동안은 로그인 가능하도록 한다.
      EXPIRE : 사용자 계쩡이 만료되는 날 
      Flag : 향후 사용할 목적으로 비워둔 항목
  
  3. /etc/login.defs (사진 첨부)
      
  4. /etc/group
       그룹 이름 : x : GID : 그룹 멤버 
       x : 그룹 암호 저장하는 곳
       GID : 그룹을 식별하는 번호 
       
  5. /etc/gshadow
       그룹 이름 : 그룹 암호 : 관리자 : 그룹 멤버
         
-사용자 계정 관리 명령
  1. 사용자 계정 생성 명령어 : useradd [옵션] 로그인 ID (사진 첨부)

  2. 사용자 계정 정보 수정 명령어 : usermod [옵션] 로그인 ID 
     옵션 : -u : UID 변경
               -d : 홈 디렉터리 변경
               -l : 로그인 ID 변경 
               
  3. 패스워드 에이징 관련 명령 : useradd, usermod, passwd, chage 명령
 
  4. 사용자 계정 삭제하는 명령어 : userdel [옵션] 로그인 ID
      옵션 : -r : 홈 디렉터리를 삭제
                -f : 사용자가 로그인 주잉어도 강제로 삭제

-그룹 관리 명령
  새 그룹 생성하는 명령어 : groupadd 
  옵션 : -g gid : 그룹의 GID를 지정
            -o : GID 중복을 허용
 
  그룹 정보 수정하는 명령어 : groupmod
  옵션 : -n 그룹명 : 그룹명을 다른 이름으로 바꿈
            -g : GID 바꾸기 
  그룹 삭제하는 명령어 : groupdel
   
  그룹 암호 설정하고 사용하는 명령어 : gpasswd 
  기능 : /etc/group 과 /etc/gshadow 파일을 관리
  옵션 : -a 사용자 계정 : 사용자 계정을 그룹에 추가
            -d 사용자 계정 : 사용자 계정을 그룹에서 삭제
            -r : 그룹 암호를 삭제

  소속 그룹 변경하는 명령어 : newgrp

-사용자 정보 관리
  1. UID 와 EUID
      UID : 사용자가 로그인할 때 사용한 계정의 UID를 의미 , EUID(유효 사용자) : 현재 명령을 수행하는 주체의 UID를 의미
      
      일반적으로 UID 와 EUID는 같으나 달라지는 경우
      -실행 파일에 setuid가 설정되어 있는 경우
      -su 명령을 사용하여 다른 계정으로 전환한 경우 
  2. 사용자 확인 명령
     현재 시스템을 사용하는 사용자의 정보를 출력하는 명령어 : who [옵션]
     옵션 : -q 사용자의 이름만 출력
               -H : 출력 항목의 제목도 함께 출력
               -b : 마지막으로 재시작한 날짜와 시간을 출력
               -m : 현재 사용자 계정의 정보를 출력
               -r : 현재 런레벨을 출력
     현재 시스템을 사용하는 사용자의 정보와 작업 정보를 출력하는 명령어 : w [사용자 이름]
     시스템에 로그인하고 로그아웃한 정보를 출력하는 명령어 : last
     UID와 EUID 출력 :whoami /  who am i , id 
     소속 그룹 확인 : groups [계정 이름]
 
  3. root 권한 사용 방법
     - su 명령을 사용해서 root 계정으로 전환하는 방법
     - 일반 사용자에게 시스템 관리 작업 중 특정 작업만 수행할 수 있는 권한을 주는 방법
         sudo 명령을 사용 , ex) sudo useradd han01 
    
  4. passwd 명령 활용
     사용자 계정의 암호를 수정하는 명령어 : passwd [옵션] [사용자 계정]
     옵션 : -l : 지정한 계정의 암호를 잠금
               -u : 암호 잠금을 해체
               -d : 지정한 계정의 암호를 삭제

  5. 파일 및 데릭터리의 소유자와 소유 그룹 변경하는 명령어 : chown [옵션] 사용자 계정 파일명/디렉터리명
      옵션 : -R : 서브 디렉터리의 소유자와 소유 그룹도 변경
      ex) chown user2 file1 ,   chown -R user2 file1
      
      파일과 디렉터리의 소유 그룹을 변경하는 명령어 : chgrp [옵션] 사용자 계정 파일명/디렉터리명
      옵션 : -R : 서브 디렉터리의 소유자와 소유 그룹도 변경

-디스크 사용량(쿼터) 설정
  디스크 쿼터 : 디스크 사용량을 제한하는 것
  
  쿼터 값 설정할 때 두가지 값 : 하드 리미트 , 소프트 리미트
  하드 리미트 : 사용자가 절대로 넘을 수 없는 최대치를 명시한 값
  소프트 리미트 : 일정 시간 내에는 넘을 수 있는 한계 값
  
  쿼터 설정을 위한 사전 준비
  -쿼터 속성을 지정
    usrquota : 개별 사용자의 쿼터를 제한할 수 있는 속성
    grpquota : 개별 그룹의 쿼터를 제한할 수 있는 속성
   
    쿼터 속성 설정
    파일 시스템의 마운트 옵션은 이미 살펴본 /etc/fstab 파일에 설정해야함.
    
    쿼터 속성 적용 
    파일 시스템을 다시 마운트해야함.
    
    쿼터 데이터베이스 파일 생성하는 명령어 : quotacheck [옵션] -a 또는 파일 시스템
    기능 : 쿼터 파일을 생성 , 확인, 수정하기 위해 파일 시스템을 스캔
    옵션 : -v : 명령 진행 상황을 상세하게 출력
    쿼터 관리하는 데이터베이스 : aquota.user , aquota.group / 사용자, 그룹 쿼터 데이터베이스 파일
    
    쿼터 사용 활성화하는 명령어 : quotaon [옵션] -a 또는 파일 시스템
    기능 : 쿼터 설정
    
    쿼터 정보 확인하는 명령어 : quota [옵션] 사용자 계정 또는 그룹명
    쿼터 설정 복사하는 명령어 : edquota -p 
    ex) edquota -p user1 user2 : user1 사용자의 쿼터 설정을 user2 사용자에 복사

    쿼터 정보 요약 출력하는 명령어 : repquota [옵션] -a 또는 파일 시스템
    
    
   
 
 
  
      



















