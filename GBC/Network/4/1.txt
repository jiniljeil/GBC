프로세스의 이해와 활용
다중접속 서버의 구현 방법들
1. 멀티프로세스 기반 서버 : 다수의 프로세스를 생성하는 방식으로 서비스 제공
2. 멀티플렉싱 기반 서버 : 입출력 대상을 묶어서 관리하는 방식으로 서비스 제공
3. 멀티쓰레딩 기반 서버 : 클라이언트의 수만큼 쓰레드를 생성하는 방식으로 서비스 제공

프로세스의 이해
만일 벽돌깨기 프로그램을 둘 이상 동시에 실행하게 되면, 실행하는 수만큼 프로세스는 생성되므로
결국 실행되는 수만큼 메모리 공간을 차지하게 됩니다.

프로세스 ID
생성되는 형태에 상관없이 운영체제로부터 ID를 부여 받은 것 ( 모든 프로세스 해당)

fork 함수
호출한 프로세스의 복사본을 생성하는 역할
즉, 전혀 새로운 다른 프로그램을 바탕으로 프로세스를 생성하는 것이 아니라 이미 실행중인, fork 함수를 호출한 프로세스를 복사하는 것

-부모 프로세스 : fork 함수의 반환 값은 자식 프로세스 ID  <-- 원본 프로세스 (fork 함수를 호출한 주체)
-자식 프로세스 : fork 함수의 반환 값은 0   <-- 복사된 프로세스

fork 함수의 반환 값의 차로 인해 부모 프로세스는 lval의 값을 1증가 시키지만 , 자식 프로세스는 lval에 영향을 미치지 않음
                                                  자식 프로세스는 gval의 값을 1증가 시키지만, 부모 프로세스는 gval에 영향을 미치지 않음. 
동일한 코드를 실행하는 완전히 다른 프로세스가 되어 lval, gval  서로 영향을 미치지 않음.

프로세스 & 좀비 프로세스

좀비 프로세스
exit 함수로 전달되는 인자 값과 main 함수의 return문에 의해 반환되는 값 모두 운영체제로 전달되어 
이 값이 자식 프로세스를 생성한 부모 프로세스에게 전달될 때까지 자식 프로세스를 소멸시키지 않는데,
바로 이 상황에 놓여있는 프로세스를 좀비 프로세스라고 함. <-- 자식 프로세스를 좀비 프로세스로 만드는 주체는 운영체제임.

부모 프로세스가 자식 프로세스의 전달 값을 요청하지 않으면, 운영체제는 그 값을 계속해서 유지하게 되고 결국 자식 프로세스는 
좀비의 상태로 오랫동안 머물러 있어야 하므로 (부모가 책임을 져야 좀비 프로세서가 발생하지 않게 됩니다.)

자식 프로세스가 종료되는 상황 두가지

1. 인자를 전달하면서 exit를 호출하는 경우
2. main 함수에서 return문을 싱행하면서 값을 반환하는 경우

좀비 프로세스의 소멸1. wait 함수의 사용

함수를 호출 했을 때 이미 종료된 자식 프로세스가 있다면 자식 프로세스가 종료되면서 전달한 값이 매개변수로 전달된 주소의
변수에 저장되는데 종료되면서 전달한 값 이외에도 다른 정보가 함께 포함되어 있어 매크로 함수를 통해서 값의 분리과정을 거쳐야함.

*WIFEXITED : 자식 프로세스가 정상 종료한 경우 '참' 을 반환 
*WEXITSTATUS : 자식 프로세스의 전달 값을 반환

wait 함수를 썼음에도 호출된 시점에서 종료된 자식 프로세스가 없다면, 임의의 자식 프로세스가 종료될 때까지 블로킹 상태에 놓임.
이 같이 블로킹이 문제가 되는 경우 waitpid 함수를 사용함

좀비 프로세스의 소멸2. waitpid 함수 의 사용 
블로킹 문제의 해결책이자 좀비 프로세스의 생성을 막는 두 번째 방법

시그널 핸들링
자식 프로세스의 종료를 기다리면서 waitpid 함수만 호출하고 있을 수 없기 때문에 운영체제가 부모 프로세스에게 
자식 프로세스가 종료 되었다는 것을 알리면 그것을 보고 부모 프로세스는 하던 일을 멈추고 자식 프로세스의 종료와 관련된 일을 처리하면 되는 것을 말함.

signal 함수를 이용한 시그널 핸들링
-> 자식 프로세스가 종료되면 운영체제에게 mychild 라는 함수를 호출 해달라하여 일을 처리하는 방법

sigaction 함수를 이용한 시그널 핸들링
->signal 함수와 유사하지만 더 안정적으로 동작한다는 이점이 있음.

다중접속-에코서버
과정
1. 에코 서버(부모 프로세스)는 accept 함수 호출을 통해서 연결요청을 수락한다.
2. 이때 얻게 되는 소켓의 파일 디스크립터를 자식 프로세스를 생성해서 넘겨준다.
3. 자식 프로세스는 전달받은 파일 디스크립터를 바탕으로 서비스를 제공한다.

fork 함수 호출을 통한 파일 디스크립터의 복사
부모 프로세스가 지니고 있던 두 소켓의 파일 디스크립터가 자식 프로세스에게 복사되었으나 소켓은 운영체제의 소유이므로 파일 디스크립터의 복사만
이루어 짐.

fork 함수호출 이후 하나의 소켓에 두 개의 파일 디스크립터가 할당되는 모습(사진 첨부)
서로에게 상관이 없는 소켓의 파일 디스크립터를 닫아줘야함.

TCP의 입출력 루틴 분할 (사진 첨부)
기존 방식은 read와 write를 반복하는 구조였기에 데이터를 전송하면 에코 되어 돌아오는 데이터를 수신할 때까지 기다려야 했었습니다.
하지만 둘 이상의 프로세스를 생성해서 부모 프로세스는 데이터의 수신을 담당, 자식 프로세스는 데이터의 송신을 담당하면 입력과 출력을 담당하는
프로세스가 각각 다르기 때문에 서버로부터의 데이터 수신여부에 상관없이 데이터를 전송할 수 있게 됨.

프로세스간 통신의 기본 개념
1. 파이프 기반의 프로세스간 통신 (사진 첨부) - 하나의 파이프
   파이프 - 소켓과 마찬가지로 운영체제에 속하는 자원
   파이프로 부터 데이터를 수신하는데 사용되는 파일 디스크립터 
   파이프로 부터 데이터를 송신하는데 사용되는 파일 디스크립터를 활용 
   부모,자식 프로세스 모두 파이프의 입출력 경로에 접근 가능하지만, 자식은 입력 경로에만, 부모는 출력 경로에만 접근해서 통신함.
 
2. 파이프 기반의 프로세스간 양방향 통신(사진 첨부)
   두 개의 파이프를 활용해서 양방향 통신을 함.

IO 멀티플렉싱 기반의 서버

멀티프로세스 서버의 단점과 대안 
단점 : 다중접속 서버의 구현을 위해서 클라이언트의 연결요청이 있을 때마다 새로운 프로세스를 생성하였는데 이는 많은 양의 연산이 요구되며,
필요한 메모리 공간도 비교적 큰편이라는 단점을 갖고 있음.
대안 : IO 멀티플렉싱을 사용하면 됨.

IO 멀티플렉싱 (사진 첨부)
--> 하나의 통신채널을 통해서 둘 이상의 데이터를 전송하는데 사용되는 기술
--> 물리적 장치의 효울성을 높이기 위해서 최소한의 물리적인 요소만 사용해서 최대한의 데이터를 전달하기 위해 사용되는 기술

장점
필요한 프로세스의 수를 줄임.
클라이언트의 수에 상관없이 서비스를 제공하는 프로세스의 수는 딱 하나라는 점 

select 함수의 이해와 서버의 구현
select 함수를 사용
-->한곳에 여러 개의 파일 디스크립터를 모아놓고 동시에 이들을 관찰할 수 있음.

관찰할 수 있는 항목
1. 수신한 데이터를 지니고 있는 소켓이 존재하는가?
2. 블로킹되지 않고 데이터의 전송이 가능한 소켓은 무엇인가 ?
3. 예외상황이 발생한 소켓은 무엇인가 ?

select 함수 호출 과정 (사진 첨부)

파일 디스크립터 (fd_set형 변수)에 값을 등록하거나 변경하는 등의 작업은 매크로함수를 이용함.

FD_ZERO(fd_set * fdset) 모든 비트를 0으로 초기화
FD_SET(int fd, fd_set *fdset) 매개변수 fdset으로 전달된 주소의 변수에 매개변수 fd로 전달된 파일 디스크립터 정보를 등록
FD_CLR(int fd, fd_set *fdset) 매개변수 fdset으로 전달된 주소의 변수에 매개변수 fd로 전달된 파일 디스크립터 정보를 삭제
FD_ISSET(int fd, fd_set *fdset) 매개변수 fdset으로 전달된 주소의 변수에 매개변수 fd로 전달된 파일 디스크립터 정보가 있으면 양수를 반환

(사진 첨부)

관찰의 범위지정과 타임아웃의 설정
1. 파일 디스크립터의 관찰 범위는 select 함수의 첫 번째 매개변수와 관련
    
2. select 함수는 관찰중인 파일 디스크립터에 변화가 생겨야 반환을 하는데 변화가 생기지 않을 경우 무한정 블로킹 상태에 머물게 되는데 
    이를 방지하기 위해 타임아웃을 지정함.

send & recv 입출력 함수
send 함수와 recv 함수의 마지막 매개변수에는 데이터 송수신시 적용할 옵션정보가 전달되지만 
옵션 정보는 비트 OR 연산자를 이용해서 둘 이상을 함께 전달 가능

옵션            |    의미 
MSG_OOB  긴급 메세지의 전송 send O recv O
MSG_PEEK 입력버퍼에 수신된 데이터의 존재유무 확인을 위한 옵션 recv O
MSG_DONTROUTE 로컬 네트워크 상에서 목적지를 찾을 떄 사용되는 옵션 send O
MSG_DONTWAIT 넌 블로킹(Non-blocking) IO의 요구에 사용되는 옵션 send O recvO
MSG_WAITALL 요청한 바이트 수에 해당하는 데이터가 전부 수신 될 때까지, 호출된 하뭇가 반환되는 것을 막기 위한 옵션 recv O

MSG_OOB (Out of band data)긴급 메세지 전송
10~13

=> 전혀 다른 통신 경로로 전송되는 데이터 
빠른 조치 / 패킷 자체가 긴급 패킷
(사진 첨부)
긴급메세지는 메세지 처리를 재촉하는데 의미가 있는 것이지 제한된 형태의 메세지를 긴급으로 전송하는데 의미가 있는 것이 아님.

입력버퍼 검사하기
MSG_PEEK  + MSG_DONTWAIT 

MSG_PEEK는 입력버퍼에 수신 된 데이터가 존재하는지 확인하는 용도로 사용 / 데이터가 지워지지 않음
MSG_DONTWAIT 블로킹 되지 않는, 데이터의 존재유무를 확인하기 위한 함수의 호출 구성에 사용 

readv & writev 입출력 함수

- 전송해야 할 데이터가 여러 개의 버퍼(배열)에 나누어 있는 경우
writev 함수 : 여러 버퍼에 나뉘어 저장되어 있는 데이터를 한번에 전송할 수 있음.

-입력버퍼에 수신된 데이터를 여러 저장소에 나눠서 읽어 들이고 싶은 경우 
readv 함수 : 데이터를 여러 버퍼에 나눠서 수신할 수 있음.

==> 입출력 함수호출 수를 줄여 성능이 향상 되게 할 수 있음. 
==> 전송되는 패킷의 수를 줄일 수 있다는데 큰 의미가 있음.

Nagle 알고리즘 OFF 상태의 데이터 전송 (사진 첨부)
1. write 함수 호출
    총 세 개의 패킷이 생성되어 전송될 확률이 높음.
2. writev 함수 호출 
    한번에 모든 데이터를 출력버퍼로 밀어 넣기 때문에 하나의 패킷만 생성되어 전송될 확률 높음.

즉 , writev & readv 함수의 호출이 유용

       













.










