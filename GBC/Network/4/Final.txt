
표준 입출력 함수의 장점
1. 표준 입출력 함수는 이식성(Protability)이 좋다.
2. 표준 입출력 함수는 버퍼링을 통한 성능의 향상에 도움이 된다.

버퍼관계 (사진 첨부)

fputs 함수를 통해 문자열을 전송했을 때
과정 
1. 표준 입출력 함수의 버퍼에 데이터가 전달된다.
2. 소켓의 출력버퍼로 이동
3. 상대방에게 문자열이 전송

버퍼는 기본적으로 성능의 향상을 목적으로함.
소켓과 관련해서 제공되는 버퍼는 TCP의 구현을 위한 목적이 더 강함.

버퍼링 장점
1. 전송하는 데이터의 양
    ex) 1바이트 10번
          10바이트 1번 
 데이터양   40 X 10
                 40 X 1
2. 출력버퍼로의 데이터 이동 횟수
    데이터 이동 횟수 줄임.
    ex) 10회 이동하는 걸리는 시간은 1회 이동하는 시간의 10배

표준 입출력 함수 사용의 단점
1. 양방향 통신이 쉽지 않다.
2. 상황에 따라서 fflush 함수의 호출이 빈번히 등장 할 수 있다.
3. 파일 디스크립터를 FILE 구조체의 포인터로 변환 해야한다.

쓰기에서 읽기로 작업의 형태를 바꿀 때마다 fflush 함수 호출 필요
기본적으로 소켓은 생성시에 파일 디스크립터를 반환하므로 파일 디스크립터를 FILE 포인터로 변환하는 과정을 거쳐야 함.

fdopen 함수 사용
포켓 생성과정에서 반환된 파일 디스크립터를 표준 입출력 함수의 인자로 전달 가능한 FILE 포인터로 변환
- 읽기모드의 FILE 포인터 생성
- 쓰기모드의 FILE 포인터 생성

fileno 함수 사용
인자로 FILE 포인터를 전달하면, 해당 파일의 파일 디스크립터가 반환 됨.

15-3 생략

스트림 분리
1. TCP의 입출력 루틴 분할
    분리 목적
    1. 입력루틴과 출력루틴의 독립을 통한 구현의 편의성 증대 
    2. 입력에 상관없이 출력이 가능하게 함으로 인해서 속도의 향상 기대

2. fdopen 함수호출로 인한 분할
    분리 목적
    1. FILE 포인터는 읽기모드와 쓰기모드를 구분해야 하므로, 읽기모드와 쓰기모드의 구분을 통한 구현의 편의성 증대
    2. 입력버퍼와 출력버퍼를 구분함으로 인한 버퍼링 기능의 향상

스트림 분리 이후의 EOF에 대한 문제점
 출력모드의 FILE 포인터를 대상으로 fclose 함수를 호출하면 데이터 수신은 가능하되 송신이 불가능한, Half-close 상황이 발생하는것이 아닌
 서버가 마지막 문자열을 수신하지 못하는 경우가 발생하는데
 그 이유는 쓰기는 물론, 읽기도 불가능한 완전 종료로 이어지기 때문입니다.
 
 fdopen 함수호출로 만들어진 FILE 포인터를 대상으로 Half-close를 진행 **
 방법  (사진 첨부)
 파일 디스크립터를 복사하여 하나 더 만들어 읽기모드 FILE 포인터와 쓰기모드 FILE 포인터를 만들면 , Half-close 환경을 만들 수 있음.
 
 파일 디스크립터 복사 방법
 fork 함수 호출에서 진행되는 복사는 프로세스 통째로 복사하는 상황에서 이루어짐으로 사용하지 못함.
 즉, "동일한 파일 또는 소켓의 접근을 위한 또 다른 파일 디스크립터의 생성"을 하기 위해선 dup 함수를 통해 복사 가능
 dup2 함수 인자로,
 0보다 크고 프로세스당 생성할 수 있는 파일 디스크립터의 수보다 작은 값을 전달하면, 해당 값을, 복사되는 파일 디스크립터의 정수 값으로 지정해준다.
 
복사 후 복사된 파일 디스크립터의 수에 상관없이 EOF의 전송을 동반하는 Half-close를 진행하기 위해서는 shutdown 함수 호출을 활용한다.

epoll의 이해와 활용

select 기반의 IO 멀티 플렉싱이 느린이유 (코드 상에서 불합리한 점)
1. select 함수호출 이후에 항상 등장하는, 모든 파일 디스크립터를 대상으로 하는 반복문
2. select 함수를 호출할 때마다 인자로 매번 전달해야 하는 관찰대상에 대한 정보들 

select 함수는 절대적으로 운영체제에 의해 기능이 완성되는 함수임으로 단점을 가지고 있어 epoll을 활용해야 한다.
epoll 방식은 리눅스에서만 지원되는 방식이며 서버의 접속자 수가 많지 않은 경우, 다양한 운영체제에서 운영이 가능해야하는 경우에는 굳이 활용할 필요가 없다.

epoll의 장점
1. 상태변화의 확인을 위한, 전체 파일 디스크립터를 대상으로 하는 반복문이 필요 없다.
2. select 함수에 대응하는 epoll_wait 함수호출 시, 관찰대상의 정보를 매번전달할 필요가 없다.

epoll_create  epoll 파일 디스크립터 저장소 생성 
epoll_ctl        저장소에 파일 디스크립터 등록 및 삭제
epoll_wait      select 함수와 마찬가지로 파일 디스크립터의 변화를 대기한다.

epoll_create 
함수호출에 의해 생성되는 리소스는 소켓과 마찬가지로 운영체제에 의해서 관리됨.
소켓이 생성될 때와 마찬가지로 파일 디스크립처를 반환함.
함수 호출 시 생성되는 파일 디스크립터의 저장소를 "epoll 인스턴스"라고 하는데 반환하는 파일 디스크립터는 epoll 인스턴스를 구분하는 목적으로 사용됨.

epoll_ctl
인스턴스 생성 후에 관찰대상이 되는 파일 디스크립터를 등록하는 역할

epoll_ctl(A, EPOLL_CTL_ADD,B,C);
뜻 : epoll 인스턴스 A에, 파일 디스크립터 B를 등록하되, C를 통해 전달된 이벤트의 관찰을 목적으로 등록을 진행
epoll_ctl(A, EPOLL_CTL_DEL,B,C);
뜻 : epoll 인스턴스 A에서 파일 디스크립터 B를 삭제

EPOLL_CTL_ADD : 파일 디스크립터를 epoll 인스턴스에 등록
EPOLL_CTL_DEL : 파일 디스크립터를 epoll 인스턴스에 삭제
EPOLL_CTL_MOD : 등록된 파일 디스크립터의 이벤트 발생상황을 변경

epoll_wait <- 가장 마지막에 호출
함수호출 후 이벤트가 발생한 파일 디스크립터의 수가 반환되고, 두 번째 인자로 전달된 주소 값의 버퍼에는 이벤트가 발생한 파일 디스크립터의 정보가 
별도로 묶이기 때문에 select 방식에서 보인 전체 파일 디스크립터를 대상으로 하는 반복문의 삽입이 불필요

레벨 트리거 방식
입력버퍼에 데이터가 남아있는 동안에 계속해서 이벤트가 등록되는 방식

엣지 트리거 방식 (사진 첨부)
데이터가 수신되면 딱 한번 이벤트가 등록되는 방식
블로킹 방식으로 read & write 함수 호출을 하면 서버를 오랜 시간 멈추는 상황으로까지 이어지게 만들 수 있기에 
반드시 넌-블로킹 소켓을 기반으로 read & write 함수를 호출 해야함.

엣지 트리거 기반의 서버 구현 배경 지식
1. 변수 errno을 이용한 오류의 원인을 확인하는 방법
2. 넌-블로킹(Non-blocking) IO 를 위한 소켓의 특성을 변경하는 방법
    int flag = fcnt1(fd, F_GETFL, 0 );
    fcnt1(fd, F_SETFL, flag|O_NONBLOCK);  <- non_blocking 모드로 변경

쓰레드의 등장배경
멀티프로세스 기반의 단점
1. 프로세스 생성이라는 부담스러운 작업과정을 거침, 
2. 두 프로세스 사이에서의 데이터 교환을 위해서는 별도의 IPC 기법을 적용해야함.
3. 초당 적게는 수십 번에서 많게는 수천 번 까지 일어나는 '컨텍스트 스위칭'

컨텍스트 스위칭 
프로그램의 실행을 위해서는 해당 프로세스의 정보가 메인 메모리에 올라와야 하는데 
A 프로세스의 뒤를 이어서 B 프로세스를 실행시키려면 A 프로세스 관련 데이터를 
메인 메모리에서 내리고 B 프로세스 관련 데이터를 메인 메모리로 이동시켜야 하는 과정

이러한 단점을 어느 정도 극복하기 위해서 쓰레드가 나오게 됨.

쓰레드 = '경량화 된 프로세스'
장점 
1. 쓰레드의 생성 및 컨텍스트 스위칭은 프로세스의 생성 및 컨텍스트 스위칭 보다 빠르다.
2. 쓰레드 사이에서의 데이터 교환에는 특별한 기법이 필요하지 않다.

둘 이상의 실행흐름을 갖는 것이 목적이라면, 완전히 메모리 구조를 분리시킬 것이 아니라, 스택 영역만을 분리시킴으로써
컨텍스트 스위칭 시 데이터 영역과 힙은 올리고 내릴 필요가 없게 만들고 데이터 영역과 힙을 이용해서 데이터를 교환 할 수 있게 만들 수 있다.

즉 , 쓰레드는 스택 영역만 독립적으로 유지하기 하므로 다음의 메모리 구조를 보인다. (사진첨부)

프로세스 : 운영체제 관점에서 별도의 실행흐름을 구성하는 단위
쓰레드 : 프로세스 관점에서 별도의 실행흐름을 구성하는 단위

쓰레드의 생성과 실행흐름의 구성 (사진 첨부)

쓰레드의 실행 시간이 있는데 이를 sleep 함수로 그 시간을 예측하는 것은 불가능하므로 pthread_join 함수를 써서 쓰레드의 실행흐름을 조절함.
pthread_join 좋은 점
ID의 쓰레드가 종료될 때 까지 함수를 호출한 프로세스를 대기상태에 둘 뿐만아니라 쓰레드의 main 함수가 반환하는 값까지 얻을 수 있음.
사진 첨부

임계영역 함수
둘 이상의 쓰레드를 동시에 실행하면 문제를 일으키는 문장이 하나 이상 존재하는 함수

워커 쓰레드 모델 (사진 첨부)
일꾼 형태를 띠며 두 개의 쓰레드를 생성해서 연산작업을 하게 하고 main 함수에서는 단지 연산결과를 출력하는 형태

쓰레드의 문제점과 임계 영역
"하나의 변수에 둘 이상의 쓰레드가 동시에 접근하는 것이 문제! "
접근 = 값의 변경 

void * thread_inc(void* arg)
{
 int i ;
 for (i=0; i<50000000;i++)
  num +=1;
  return NULL;
}
void * thread_des(void* arg)
{
 int i ;
 for (i=0; i<50000000;i++)
  num -=1;
  return NULL;
}
변수 num에 접근하는 두 문장이 임계영역에 해당함.
이 두 문장은 둘 이상의 쓰레드에 의해서 동시에 실행되도록 구현되어있는, 문제를 일의는 직접적인 원인임.
문제 발생 상황
1. 두 쓰레드가 동시에 thread_inc 함수를 실행하는 경우
2. 두 쓰레드가 동시에 thread_des 함수를 실행하는 경우
3. 두 쓰레드가 각각 thread_inc 함수와 thread_des 함수를 동시에 실행하는 경우

즉, 쓰레드 1이 thread_inc 함수의 문장 num+=1 을 실행할 때 , 동시에 쓰레드2가 thread_des 함수의 문장 num-=1을 실행하는 상황

쓰레드 동기화
1. 뮤텍스
    동시접근을 허용하지 않게하고 주로 쓰레드의 동기접근에 대한 해결책으로 사용됨
    ex) 임계영역 : 화장실
          한 사람이 나와야 다른 사람이 들어가는 형식 (자물쇠 시스템)  
2. 세마포어
    sem_post 함수 호출로 인해 1 증가 , sem_wait 함수 호출로 인해 1 감소 이를 반복해서 임계영역을 동기화시키게 함.
     
   쓰레드를 소멸 하지 않으면 할당된 메모리 공간이 계속해서 남아있게 되어 소멸 시켜 줘야함.  
   쓰레드를 소멸하는 방법
   pthread_join 함수가 호출되면, 쓰레드의 종료를 대기할 뿐만 아니라, 쓰레드의 소멸까지 유도가 된다. 하지만 쓰레드가 종료될 때 블로킹 상태에 놓이게 됨.
   pthread_detach 함수는 쓰레드에게 할당된 메모리의 소멸을 유도할 수 있음.
  



    





 
























