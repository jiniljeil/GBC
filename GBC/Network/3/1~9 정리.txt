1. 연결지향형 소켓
   socket 함수의 두 번째 인자로 SOCK_STREAM을 전달하면 연결지향형 소켓이 됨.
   
  특징
  1. 중간에 데이터가 소멸되지 않고 목적지로 전송된다.
  2. 전송 순서대로 데이터가 수신된다.
  3. 전송되는 데이터의 경계가 존재하지 않는다.
 
  자신과 연결된 상대 소켓의 상태를 파악해가면서 데이터를 전송
  데이터 손실 잘 안일어남

2. 비 연결지향형 소켓
  socket 함수의 두 번째 인자로 SOCK_DGRAM을 전달하면 비 연결지향형 소켓이 됨.

  특징
  1. 전송된 순서에 상관없이 가장 빠른 전송을 지향한다.
  2. 전송된 데이터는 손실의 우려가 있고, 파손의 우려가 있다.
  3. 전송되는 데이터의 경계가 존재한다.
  4. 한번에 전송할 수 있는 데이터의 크기가 제한된다. 

 
"하나의 프로토콜 체계 안에 데이터의 전송방식이 동일한 프로토콜이 둘 이상 존재하는 경우" 세 번째 인자가 필요!!
즉 , 소켓의 데이터 전송방식은 같지만, 그 안에서도 프로토콜이 다시 나뉘는 상황이 존재할 수 있기 때문에
이러한 상황에서 세 번째 인자를 통해 원하는 프로토콜 정보를 조금 더 구체화 해야함.

IP(Internet Protocol)
인터넷상에서 데이터를 송수신할 목적으로 컴퓨터에게 부여하는 값

IP는 데이터가 NIC(네트워크 인터페이스 카드)를 통해 컴퓨터 내부로 전송하는데 사용됨.
NIC - 송수신장치가 하나씩 달려있음.

IP 주소
- IPv4     4byte 주소체계
- IPv6   16byte 주소체계

클래스 A 첫 번째 바이트 범위 0~126
클래스 B 첫 번째 바이트 범위 128~191
클래스 C 첫 번째 바이트 범위 192~223

PORT
컴퓨터에 부여하는 값이 아닌, 프로그램상에서 생성되는 소켓을 구분하기 위해 소켓에 부여되는 번호
하나의 운영체제 내에서 소켓을 구분하는 목적으로 사용되기 때문에 하나의 운영체제 내에서 동일한 PORT 번호를 
둘 이상의 소켓에 할당할 수 없음.

운영체제
PORT 번호 활용
NIC를 통해서 수신된 데이터 안에는 PORT 번호가 새겨져 있음.
일치하는 PORT 번호의 소켓에 데이터를 전달

주소 정보의 표현   (사진 첨부)
IPv4 기반의 주소표현을 위한 구조체
구조체는 bind 함수에 주소정보를 전달하는 용도로 사용됨. // 생략

네트워크 바이트 순서와 
CPU가 데이터를 메모리에 저장하는 방식 (사진 첨부)
1. 빅 엔디안
  상위 바이트의 값을 작은 번지수에 저장하는 방식

2. 리틀 엔디안
  상위 바이트의 값을 큰 번지수에 저장하는 방식

빅 0x12 0x34 
리틀 0x34 0x12 
이러한 문제점으로 인해 네트워크를 통해서 데이터를 전송할 때에는 통일된 기준으로 데이터를 전송하기로 약속

memset 함수 = 동일한 값으로 바이트단위 초기화를 할 때 호출하는 함수 // 생략

3-4 다시

TCP 소켓(스트림 기반 소켓)

UDP 소켓

TCP/IP 프로토콜 스택 (사진 첨부)
인터넷 기반의 효율적인 데이터 전송이라는 문제를 작게 나눠서 계층화 시킨 것

Link 계층 
LINK계층은 물리적인 영역의 표준화에 결과이다. 이는 가장 기본이 되는 영역으로 
LAN,WAN,MAN과 같은 네트워크 표준과 관련된 프로토콜을 정의하는 영역이다. 
두 호스트가 인터넷을 통해 데이터를 주고받기 위해 물리적인 연결이 존재해야 하는데 
이부분에 대한 표준을 LINK계층에서 담당함.

IP 계층
목적지로 데이터를 전송하기 위해서 거치는 경로를 결정하는게 바로 IP계층이고, 이떄 사용하는 프로토콜이 IP이다.
IP자체는 비 연결지향적이며 신뢰할 수 없는 프로토콜입니다. 
데이터를 전송할 때마다 거쳐야 할 경로를 설정해 주지만, 경로는 일정치 않고, 
혹시 데이터 전송 도중 경로상 문제가 발생하면 다른 경로를 선택해 주는데, 
이과정에서 데이터가 손실되거나 오류가 발생하는 등의 문제가 발생한다고 해서 이를 해결해주지 않는다.
 즉 오류발생에 대한 대비가 되어있지 않은 프로토콜이다.

TCP/UDP 계층
호스트 대 호스트의 데이터 송수신 방식을 약속한 것이 TCP/UDP이며, 
TCP는 확인절차를 걸쳐서 신뢰성이 없는 IP에 신뢰성을 부여한 프로토콜이다. 
데이터 전송을 위한 경로를 IP에서 설정해줬으므로, 데이터를 전송할 일만 남았다. 
TCP/UDP는 IP계층에서 알려준 정보를 바탕으로 데이터의 실제 송수신을 담당한다.(4 - 전송계층)
TCP프로토콜이 추가 된다면 데이터를 송수신할때 받았는지 확인절차를 거치기 때문에 신뢰성이 증가함.

APPLICATION 계층
소켓을 이용해 무엇인가를 만드는 과정에서 프로그램의 성격에 따라 클라이언트와 서버간의 데이터 송수신에 대한 
약속들을 APPLICATION프로토콜이라고 한다.

출처: https://taesun1114.tistory.com/entry/TCP-IP-프로토콜-스택 []

TCP 서버에서의 기본적인 함수호출 순서 (사진 첨부)

listen() 함수 (연결요청 대기상태) 가 호출 되면 에서 문지기의 역할을 하는 서버 소켓이 만들어지고 listen 함수의 
두 번째 인자로 전달되는 정수의 크기에 해당하는 대기실이 만들어짐.

이후
accept() 함수는 연결 요청 하나를 꺼내서 새로운 소켓을 생성한 후 연결요청을 완료하는 역할을 함.
새로운 소켓 만들고 연결 구성하면 생성된 소켓의 파일 디스크립터를 반환함. 
클라이언트의 연결요청이 들어올 때까지 accept 함수는 반환 x 

write 함수 클라이언트에게 데이터를 전송  // 송수신

close 함수 연결을 끊음.

TCP 클라이언트 기본적인 함수호출 순서 (사진 첨부)
socket -> connect -> read/write -> close

클라이언트는 연결요청 과정에서 서버 구현과정과 조금 다르다 .

에코서버
문자열 데이터를 에코시키는 서버 (사진 첨부)

TCP 소켓에 존재하는 입출력 버퍼 (사진첨부)
write 함수가 호출되는 순간 데이터는 출력버퍼로 이동하고, read 함수가 호출되는 순간 입력버퍼에 저장된 데이터를 읽어들이게 된다.
이를 통해 상대방은 read 함수 호출을 통해서 입력버퍼에 저장된 데이터를 읽게 되는 것

서로 대화를 주고받으면서 데이터를 송수신하기 때문에, 버퍼가 차고 넘쳐서 데이터가 소멸되는 일이 TCP에서는 발생하지 않음.

TCP 소켓의 생성에서 소멸의 과정까지 거치는 일을 나누면 (내부 동작원리)

1. 상대 소켓과의 연결 (사진)
   한 차례 씩 송수신한 패킷에서 볼 수 있듯이 TCP의 연결과정에서 패킷을 보낼 떄에는 항상 번호를 부여함.
   데이터 송수신을 위한 준비
2. 상대 소켓과의 데이터 송수신(사진)
   ACK 번호 = SEQ 번호 + 전송된 바이트 크기 + 1
   만일 문제 발생으로 인해 데이터 전송을 하지 못했다면 TCP 소켓은 ACK 응답을 구하는 패킷 전송 시에 타이머를 동작시켜 
   타이머가 시간을 다 했을 때 패킷을 재전송합니다. 

3. 상대 소켓과의 연결종료(사진)
    상대방이 전송할 데이터가 남아있을 때 상호간에 연결종료의 합의과정을 거쳐야 문제가 되지 않는다.
    패킷 안에 삽입되어 있는 FIN = 종료를 알리는 메세지를 뜻함.

    신뢰성 TCP > UDP
    간결성 UDP> TCP
   
    TCP 
    흐름제어 존재
    데이터 손실 x
    TCP 서버는 클라이언트와 서버가 연결된 상태로 데이터를 송수신함.
    서버에서 열 개의 클라이언트에게 서비스를 제공하려면 문지기의 역할을 하는 서버 소켓을 제외하고도 열 개의 소켓이 필요
    TCP 소켓은 목적지에 해당하는 소켓과 연결된 상태이므로 주소 정보를 다로 추가하는 과정이 필요 X
    송수신하는 데이터에 경계가 존재하지 않음. = 호출하는 입출력함수와 호출횟수는 큰 의미를 지니고 있지 않다.


    UDP
    중요 역할 : 호스트로 수신된 패킷을 PORT 정보를 참조하여 최종 목적지인 UDP 소켓에 전달하는 것
    데이터 손실 가능 O 
    UDP 서버는 TCP와 같이 클라이언트와 연결된 상태로 데이터를 송수신 하지 않음.
    listen 또는 accept 함수의 호출이 불필요
    서버건 클라이언트건 하나의 소켓만 있으면 둘 이상의 호스트와 통신이 가능
    목적지 주소정보를 요구함. 발신지가 일정하지 않아 발신지 정보를 얻을 수 있는 함수가 필요
    sendto 함수 호출 시 IP와 PORT번호가 자동으로 할당되기 때문에 TCP와 달리 UDP의 클라이언트 프로그램에서는 
    주소 정보를 할당하는 별도의 과정이 필요가 없음.
    송수신하는 데이터에 경계가 존재함. = 입력함수의 호출횟수와 출력함수의 호출횟수가 완벽히 일치해야 송신된 데이터 전부를 수신 가능 

   unconnect UDP 소켓
   목적지 정보가 등록되어 있지 않은 소켓
   
   connect UDP 소켓
   목적지 정보가 등록되어 있는 소켓 (connect 함수를 포함)

   Half - Close
   양방향으로 통신하고 있는 두 호스트에 Close 함수가 호출 되면 연결을 종료하게 되는데 
   수신 도중 꼭 필요한 데이터를 받지 못하고 종료하게 되거나 또는 그 반대의 상황이 일어나게 되는 것을
   방지 하기 위해 만들어 진 것 즉, 스트림의 반만 닫음
   
   shutdown 함수 사용
   -SHUT_RD 입력 스트림 종료
   -SHUT_WR 출력 스트림 종료
   -SHUT_RDWR 입출력 스트림 종료

   Stream 
   두 소켓이 연결되어서 데이터의 송수신이 가능한 상태
   (사진) 
 
   도메인 이름이란 ?
   
   도메인 네임은 넓은 의미로는 네트워크상에서 컴퓨터를 식별하는 호스트명을 가리키며, 
   좁은 의미에서는 도메인 레지스트리에게서 등록된 이름을 의미한다.  



   이것은 기억하기 쉽지 않은 IP주소의 형태로 서버의 주소정보를 기억하는 것은 사실상 불가능한 일이므로 IP 주소를 대신하도록 함.
 
   DNS 서버
   IP주소와 도메인 이름 사이에서의 변환을 수행하는 시스템
   계층적으로 관리되는 일종의 분산 데이터베이스 시스템

   디폴트 DNS서버가 모든 도메인의 IP 주소를 알고 있지 않지만 다른 DNS 서버에게 물어서라도 가르쳐줌.
   
   과정   
   디폴트 DNS 서버가 자신이 모르는 정보에대한 요청이 들어오면 상위 계층에 있는 DNS 서버에게 물어보는데 
   이런 식으로 계속 올라가다가 상위 계층은 다시 하위계층에 있는 DNS 서버에게 다시 질문을 던져 IP를 얻어냄.
   
   도메인 이름을 사용하는 이유

   IP주소는 도메인 이름에 비해 상대적으로 변경의 확률이 높기 때문에 도메인 이름을 등록하고 나면 평생 유지가 가능함으로
   이를 활용하면 프로그램이 실행될 때마다 도메인 이름을 근거로 IP주소를 얻어온 다음에 서버에 접속을 하게 되어 
   서버의 IP주소로 부터 클라이언트 프로그램은 자유로워 지기 때문
  
  소켓의 옵션과 입출력 버퍼의 크기
   

   주소 할당에러 발생
   Time -wait 상태 (사진 첨부)
   호스트 A가 호스트 B로 마지막 ACK메세지를 전송하고 나서 바로 소멸시켰다고 하면 마지막 ACK메세지가 호스트 B로 전달되지 못하고  
   중간에 소멸 되어 버립니다. 호스트 B가 재 전송을 시도하더라도 A는 종료 상태이므로 결국 마지막 ACK 메세지를 못받게 되는 상황이 
   발생하게 됩니다.
   이런 상황을 방지하기 위해 TIme -wait 타이머를 가동하여 전달 받지 못하였을 때 재가동하게 해서 정상적으로 전달을 마치고 
   종료할 수 있게 도움을 주는 역할을 합니다. 
   
    만일 네트워크 상황이 원활하지 못하면 Time -wait가 언제까지 지속될지 모르는 상황이 나타나게 되는데 
    이것은 소켓의 옵션 중에 SO_REUSEADDR의 디폴트 값을 1로 변경해주면 해결해 줄 수 있습니다.

    Nagle 알고리즘
    앞서 전송한 데이터에 대한 ACK 메세지를 받아야만 다음 데이터를 전송하는 알고리즘

    Nagle 알고리즘을 사용하는 것 보다 데이터 전송이 빠를 경우
    TCP_NODELAY를 1 (TRUE) 로 변경해주면 됨.

    


   








































